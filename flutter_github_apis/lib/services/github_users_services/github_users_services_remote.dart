// ignore_for_file: public_member_api_docs, unnecessary_this

/*
 * Autogenerated header by File Header Comment extension - Donna Iwan
 * File:       github_usersservices_remote.dart
 * Created on: Fri Jul 08 2022
 * Author:     Nguyen Huu Nghi
 *
 * Copyright (c) 2022 Nguyen Huu Nghi
 *
 * Description 
 */
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
import 'package:ua_client_hints/ua_client_hints.dart';

import '../../model/github_user.dart';
import '../../utils/utilities.dart';
import '../local_storage_services/local_storage_services.dart';
import 'github_users_services.dart';

/// This class used to interface with users through github API.
class GitHubUsersServicesRemote extends GitHubUsersServices {
  GitHubUsersServicesRemote._internal() {
    cacheUsersValidDuration_ = const Duration(minutes: 5);
    lastFetchUsersTime_ = DateTime.fromMillisecondsSinceEpoch(0);
    cacheUserValidDuration_ = const Duration(minutes: 5);
  }

  /// Instance
  static final GitHubUsersServicesRemote instance =
      GitHubUsersServicesRemote._internal();
  late Duration cacheUsersValidDuration_;
  late DateTime lastFetchUsersTime_;
  late Duration cacheUserValidDuration_;
  List<GitHubUser> users_ = [];

  /// Record log for users.
  List<Map<String, dynamic>> usersLog_ = [];
  final url_ = 'https://api.github.com/users';
  @override
  Future<List<GitHubUser>> getAllUsers() async {
    Utils.log(
      title: 'REMOTE',
      info: 'Start get new users.',
    );
    var users = <GitHubUser>[];
    try {
      final ua = await userAgent();
      Utils.log(
        title: 'USER-AGENT',
        info: ua,
      );
      final response = await http.get(
        Uri.parse('$url_?since=1&per_page=10'),
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': ua,
        },
      );
      Utils.log(
        title: 'REMOTE',
        info: 'Response from server [${response.statusCode}].',
      );
      if (response.statusCode == 200) {
        users = await compute(
          _usersParser,
          jsonDecode(response.body) as List<dynamic>,
        );
        Utils.log(
          title: 'REMOTE',
          info: 'Get new ${users.length} users.',
        );
        for (var i = 0; i < users.length; i++) {
          users[i] = (await getUserInfo(users[i].login))!;
        }
      }
    } catch (e) {
      throw ArgumentError(e.toString());
    }
    return users;
  }

  Future<String?> _saveFile({
    required String url,
    required String fileName,
  }) async {
    final response = await http.get(
      Uri.parse(
        url,
      ),
    );
    if (response.statusCode == 200) {
      await LocalStorageServices.instance.saveFile(
        filePath:
            '${LocalStorageServices.instance.path()}/${LocalStorageServices.imagesDirName}/$fileName.tmp',
        bytes: response.bodyBytes.toList(),
      );
      return '${LocalStorageServices.instance.path()}/${LocalStorageServices.imagesDirName}/$fileName.tmp';
    } else {
      return null;
    }
  }

  Future<void> _fetchAllUsersRecords() async {
    Utils.log(title: 'REMOTE', info: 'Fetch all users.');

    for (final mUser in [...users_]) {
      final user = await getUserInfo(mUser.login);
      final logIdx = usersLog_.indexWhere(
        (element) => (element['login'] as String) == mUser.login,
      );
      if (logIdx != -1) {
        usersLog_[logIdx].update(
          'lastTime',
          (value) => DateTime.now(),
        );
      } else {
        usersLog_.add({
          'lastTime': DateTime.now(),
          'login': mUser.login,
        });
      }
      if (user == null) {
        users_.removeWhere(
          (element) => element.login == mUser.login,
        );
      }
    }
  }

  Future<void> _refreshAllUsersRecords() async {
    if (users_.isNotEmpty) {
      Utils.log(title: 'REMOTE', info: 'Fetch ${users_.length} users ');

      await _fetchAllUsersRecords();
    } else {
      this.saveAllUsers(users: await getAllUsers());
    }
    lastFetchUsersTime_ = DateTime.now();
  }

  @override
  Future<Map<String, dynamic>> getAllUsersRecords({
    bool forceRefresh = false,
  }) async {
    final shouldRefreshFromAPI = forceRefresh ||
        users_.isEmpty ||
        lastFetchUsersTime_
            .isBefore(DateTime.now().subtract(cacheUsersValidDuration_));

    if (shouldRefreshFromAPI) {
      Utils.log(title: 'REMOTE', info: 'Should refresh data.');

      await _refreshAllUsersRecords();
    } else {
      Utils.log(title: 'CACHE', info: 'Get all users data.');
    }
    return {
      'data': users_,
      'cache': !shouldRefreshFromAPI,
    };
  }

  @override
  Future<GitHubUser?> getUserInfo(String login) async {
    try {
      Utils.log(title: 'REMOTE', info: 'Get user data.');
      final ua = await userAgent();
      Utils.log(
        title: 'USER-AGENT',
        info: ua,
      );
      final response = await http.get(
        Uri.parse('$url_/$login'),
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': ua,
        },
      );
      if (response.statusCode == 200) {
        final user = GitHubUser.fromMap(
          Map<String, dynamic>.from(
            jsonDecode(response.body) as Map<dynamic, dynamic>,
          ),
        );

        ///Stored this user to buffer.

        final path = await _saveFile(
          url: user.avatar_url,
          fileName: user.login,
        );
        user.avatar_path = path;

        this.saveUser(user: user);
        return user;
      } else {
        Utils.log(title: 'RESPONSE', info: 'STATUS[${response.statusCode}]');

        ///status code == 404 (resource not found)
        ///status code == 403 (Forbidden)
        return null;
      }
    } catch (e) {
      throw ArgumentError(e.toString());
    }
  }

  @override
  Future<Map<String, dynamic>> getUserInfoRecords({
    required GitHubUser user,
    bool forceRefresh = false,
  }) async {
    final logIdx = usersLog_.indexWhere(
      (element) => (element['login'] as String) == user.login,
    );
    final lastFetchUserTime = logIdx != -1
        ? usersLog_[logIdx]['lastTime'] as DateTime
        : DateTime.fromMillisecondsSinceEpoch(0);
    final shouldRefreshFromAPI = forceRefresh ||
        lastFetchUserTime
            .isBefore(DateTime.now().subtract(cacheUserValidDuration_));
    if (shouldRefreshFromAPI) {
      if (logIdx != -1) {
        usersLog_[logIdx].update(
          'lastTime',
          (value) => DateTime.now(),
        );
      } else {
        usersLog_.add({
          'lastTime': DateTime.now(),
          'login': user.login,
        });
      }

      return {
        'data': (await getUserInfo(user.login)) ?? user,
        'cache': false,
      };
    } else {
      Utils.log(title: 'CACHE', info: 'Get user data.');

      return {
        'data': user,
        'cache': true,
      };
    }
  }

  static List<GitHubUser> _usersParser(List<dynamic> data) {
    return data
        .map(
          (e) => GitHubUser.fromMap(
            Map<String, dynamic>.from(e as Map<dynamic, dynamic>),
          ),
        )
        .toList();
  }

  @override
  void saveAllUsers({required List<GitHubUser> users}) {
    Utils.log(
      title: 'CACHE',
      info: 'Save ${users.length} users data to cache.',
    );
    users_ = [...users];
  }

  @override
  void saveUser({
    required GitHubUser user,
  }) {
    Utils.log(title: 'CACHE', info: 'Save user data to cache.');

    users_ = [
      for (final mUser in users_)
        if (mUser.id == user.id) user else mUser,
    ];
  }

  @override
  int checkUsersBuffer() {
    return users_.length;
  }
}
