// ignore_for_file: public_member_api_docs, unnecessary_this

import 'dart:convert';

/*
 * Autogenerated header by File Header Comment extension - Donna Iwan
 * File:       github_usersservices_remote.dart
 * Created on: Fri Jul 08 2022
 * Author:     Nguyen Huu Nghi
 *
 * Copyright (c) 2022 Nguyen Huu Nghi
 *
 * Description 
 */
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;

import '../../model/github_user.dart';
import '../../utils/utilities.dart';
import '../local_storage_services/local_storage_services.dart';
import 'github_users_services.dart';

/// This class used to interface with users through github API.
class GitHubUsersServicesRemote extends GitHubUsersServices {
  GitHubUsersServicesRemote._internal() {
    cacheUsersValidDuration_ = const Duration(minutes: 5);
    lastFetchUsersTime_ = DateTime.fromMillisecondsSinceEpoch(0);
    cacheUserValidDuration_ = const Duration(minutes: 5);
  }

  /// Instance
  static final GitHubUsersServicesRemote instance =
      GitHubUsersServicesRemote._internal();
  late Duration cacheUsersValidDuration_;
  late DateTime lastFetchUsersTime_;
  late Duration cacheUserValidDuration_;
  List<GitHubUser> users_ = [];

  /// Record log for users.
  List<Map<String, dynamic>> usersLog_ = [];
  final url_ = 'https://api.github.com/users';
  @override
  Future<List<GitHubUser>> getAllUsers() async {
    var users = <GitHubUser>[];
    try {
      final response = await http.get(
        Uri.parse('$url_?since=2'),
        headers: {
          'Content-Type': 'application/json',
        },
      );
      if (response.statusCode == 200) {
        users = await compute(
          _usersParser,
          jsonDecode(response.body) as List<dynamic>,
        );

        for (var i = 0; i < users.length; i++) {
          if (users[i].avatar_url != null) {
            final path = await _saveFile(
              url: users[i].avatar_url ?? '',
              fileName: users[i].login ?? '',
            );
            Utils.log(
              title: 'USERS',
              info: 'Get new ${users.length} users from API.',
            );

            users[i].avatar_path = path;
          }
        }
      }
    } catch (e) {
      throw ArgumentError(e.toString());
    }
    return users;
  }

  Future<String?> _saveFile({
    required String url,
    required String fileName,
  }) async {
    final response = await http.get(
      Uri.parse(
        url,
      ),
    );
    if (response.statusCode == 200) {
      await LocalStorageServices.instance.saveFile(
        filePath:
            '${LocalStorageServices.instance.path()}/${LocalStorageServices.imagesDirName}/$fileName.tmp',
        bytes: response.bodyBytes.toList(),
      );
      return '${LocalStorageServices.instance.path()}/${LocalStorageServices.imagesDirName}/$fileName.tmp';
    } else {
      return null;
    }
  }

  Future<void> _fetchAllUsersRecords() async {
    Utils.log(title: 'USERS', info: 'Fetch all users from API.');

    for (final mUser in [...users_]) {
      final user = await getUserInfo(mUser.login ?? '');

      if (user == null) {
        users_.removeWhere(
          (element) => element.login == mUser.login,
        );
      }
    }
  }

  Future<void> _refreshAllUsersRecords() async {
    if (users_.isNotEmpty) {
      Utils.log(title: 'USERS', info: users_.length);

      await _fetchAllUsersRecords();
    } else {
      this.saveAllUsers(users: await getAllUsers());
    }
    lastFetchUsersTime_ = DateTime.now();
  }

  @override
  Future<Map<String, dynamic>> getAllUsersRecords({
    bool forceRefresh = false,
  }) async {
    final shouldRefreshFromAPI = forceRefresh ||
        users_.isEmpty ||
        lastFetchUsersTime_
            .isBefore(DateTime.now().subtract(cacheUsersValidDuration_));
    if (shouldRefreshFromAPI) {
      await _refreshAllUsersRecords();
    } else {
      Utils.log(title: 'USERS', info: 'Get old users from cache.');
    }
    return {
      'data': users_,
      'cache': !shouldRefreshFromAPI,
    };
  }

  @override
  Future<GitHubUser?> getUserInfo(String login) async {
    try {
      Utils.log(title: 'USER', info: 'Get user data from API.');

      final response = await http.get(
        Uri.parse('$url_/$login'),
        headers: {
          'Content-Type': 'application/json',
        },
      );
      if (response.statusCode == 200) {
        final user = GitHubUser.fromMap(
          Map<String, dynamic>.from(
            jsonDecode(response.body) as Map<dynamic, dynamic>,
          ),
        );

        ///Stored this user to buffer.
        if (user.avatar_url != null) {
          final path = await _saveFile(
            url: user.avatar_url ?? '',
            fileName: user.login ?? '',
          );
          user.avatar_path = path;
        }
        this.saveUser(user: user);
        return user;
      } else {
        ///status code == 404 (resource not found)
        return null;
      }
    } catch (e) {
      throw ArgumentError(e.toString());
    }
  }

  @override
  Future<Map<String, dynamic>> getUserInfoRecords({
    required GitHubUser user,
    bool forceRefresh = false,
  }) async {
    final logIdx = usersLog_.indexWhere(
      (element) => (element['login'] as String) == user.login,
    );
    final lastFetchUserTime = logIdx != -1
        ? usersLog_[logIdx]['lastTime'] as DateTime
        : DateTime.fromMillisecondsSinceEpoch(0);
    final shouldRefreshFromAPI = forceRefresh ||
        lastFetchUserTime
            .isBefore(DateTime.now().subtract(cacheUserValidDuration_));
    if (shouldRefreshFromAPI) {
      if (logIdx != -1) {
        usersLog_[logIdx].update(
          'lastTime',
          (value) => DateTime.now(),
        );
      } else {
        usersLog_.add({
          'lastTime': DateTime.now(),
          'login': user.login,
        });
      }
      return {
        'data': await getUserInfo(user.login ?? ''),
        'cache': false,
      };
    } else {
      Utils.log(title: 'USER', info: 'Get user data from cache.');

      return {
        'data': user,
        'cache': true,
      };
    }
  }

  static List<GitHubUser> _usersParser(List<dynamic> data) {
    return data
        .map(
          (e) => GitHubUser.fromMap(
            Map<String, dynamic>.from(e as Map<dynamic, dynamic>),
          ),
        )
        .toList();
  }

  @override
  void saveAllUsers({required List<GitHubUser> users}) {
    Utils.log(title: 'USERS', info: 'Save users data to cache.');
    users_ = [...users];
  }

  @override
  void saveUser({
    required GitHubUser user,
  }) {
    Utils.log(title: 'USER', info: 'Save user data to cache.');

    users_ = [
      for (final mUser in users_)
        if (mUser.id == user.id) user else mUser,
    ];
  }

  @override
  int checkUsersBuffer() {
    return users_.length;
  }
}
